{
  "issue_id": 2412,
  "issue_url": "https://github.com/mockito/mockito/issues/2412",
  "title": "Some VerificationModes don't have a toString implementation.",
  "description": "<p dir=\"auto\">Some user-facing VerificationModes don't have a <code class=\"notranslate\">toString()</code> implementation. This includes:</p>\n<ul dir=\"auto\">\n<li><code class=\"notranslate\">AtMost</code></li>\n<li><code class=\"notranslate\">Only</code></li>\n<li><code class=\"notranslate\">After</code></li>\n<li><code class=\"notranslate\">Timeout</code></li>\n</ul>\n<p dir=\"auto\">I ran into this issue while using Mockito with a proprietary <a href=\"https://jasmine.github.io/\" rel=\"nofollow\">Jasmine</a>-like library for JUnit. Here is a short example written with JUnit and the open-source runner <a href=\"https://github.com/mscharhag/oleaster\">Oleaster</a>:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"@RunWith(OleasterRunner.class)\npublic class DemoTest {\n\n    private MyClass myClass;\n\n    {\n        describe(\"demo\", () -> {\n\n            beforeEach(() -> {\n                myClass = Mockito.mock(MyClass.class);\n                myClass.myMethod();\n            });\n\n            verifyMyMethodCalled(atLeast(1));\n            verifyMyMethodCalled(atMost(1));\n            verifyMyMethodCalled(only());\n            verifyMyMethodCalled(after(1));\n        });\n    }\n\n    private void verifyMyMethodCalled(VerificationMode verificationMode) {\n        it(String.format(\"should call myMethod. %s\", verificationMode), () -> {\n            verify(myClass, verificationMode).myMethod();\n        });\n    }\n}\"><pre class=\"notranslate\"><code>@RunWith(OleasterRunner.class)\npublic class DemoTest {\n\n    private MyClass myClass;\n\n    {\n        describe(\"demo\", () -> {\n\n            beforeEach(() -> {\n                myClass = Mockito.mock(MyClass.class);\n                myClass.myMethod();\n            });\n\n            verifyMyMethodCalled(atLeast(1));\n            verifyMyMethodCalled(atMost(1));\n            verifyMyMethodCalled(only());\n            verifyMyMethodCalled(after(1));\n        });\n    }\n\n    private void verifyMyMethodCalled(VerificationMode verificationMode) {\n        it(String.format(\"should call myMethod. %s\", verificationMode), () -> {\n            verify(myClass, verificationMode).myMethod();\n        });\n    }\n}\n</code></pre></div>\n<p dir=\"auto\">Extracting the assertion and the test-naming part to a specific method (<code class=\"notranslate\">verifyMyMethodCalled(VerificationMode verificationMode)</code>) saves a lot of boilerplate and helps with maintainability, especially since a real-life test class will most likely be longer than this example. However, the following screenshot shows why the last 3 verificationModes aren't so helpful without a proper <code class=\"notranslate\">toString()</code> method:</p>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/22927506/131226758-72a58f27-c1fb-44e2-8db2-70ab5476c7f5.png\"><img src=\"https://user-images.githubusercontent.com/22927506/131226758-72a58f27-c1fb-44e2-8db2-70ab5476c7f5.png\" alt=\"image\" style=\"max-width: 100%;\"></a></p>\n<p dir=\"auto\">I fixed this, in my use case, this by extending the offending <code class=\"notranslate\">VerificationMode</code> in a custom factory method:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"private static VerificationMode atMost(int times) {\n    return new AtMost(times) {\n        @Override\n        public void verify(VerificationData data) {\n            super.verify(data);\n        }\n\n        @Override\n        public String toString() {\n            return \"Wanted invocations count: at most \" + times;\n        }\n    };\n}\"><pre class=\"notranslate\"><code>private static VerificationMode atMost(int times) {\n    return new AtMost(times) {\n        @Override\n        public void verify(VerificationData data) {\n            super.verify(data);\n        }\n\n        @Override\n        public String toString() {\n            return \"Wanted invocations count: at most \" + times;\n        }\n    };\n}\n</code></pre></div>\n<p dir=\"auto\">This quickly becomes cumbersome however, if you want to do it for multiple <code class=\"notranslate\">VerificationMode</code>s or in multiple projects. Since most user-facing <code class=\"notranslate\">VerificationMode</code>s already have a <code class=\"notranslate\">toString()</code> method (e.g. <code class=\"notranslate\">atLeast</code> in my example), the missing <code class=\"notranslate\">toString()</code> methods could be included in Mockito.</p>\n<p dir=\"auto\">I have a PR that is almost ready for this, and would gladly submit it.</p>\n<p dir=\"auto\">EDIT: added <code class=\"notranslate\">Timeout</code> to the list.</p>",
  "description_text": "Some user-facing VerificationModes don't have a toString() implementation. This includes:\n\nAtMost\nOnly\nAfter\nTimeout\n\nI ran into this issue while using Mockito with a proprietary Jasmine-like library for JUnit. Here is a short example written with JUnit and the open-source runner Oleaster:\n {\n\n            beforeEach(() -> {\n                myClass = Mockito.mock(MyClass.class);\n                myClass.myMethod();\n            });\n\n            verifyMyMethodCalled(atLeast(1));\n            verifyMyMethodCalled(atMost(1));\n            verifyMyMethodCalled(only());\n            verifyMyMethodCalled(after(1));\n        });\n    }\n\n    private void verifyMyMethodCalled(VerificationMode verificationMode) {\n        it(String.format(\"should call myMethod. %s\", verificationMode), () -> {\n            verify(myClass, verificationMode).myMethod();\n        });\n    }\n}\">@RunWith(OleasterRunner.class)\npublic class DemoTest {\n\n    private MyClass myClass;\n\n    {\n        describe(\"demo\", () -> {\n\n            beforeEach(() -> {\n                myClass = Mockito.mock(MyClass.class);\n                myClass.myMethod();\n            });\n\n            verifyMyMethodCalled(atLeast(1));\n            verifyMyMethodCalled(atMost(1));\n            verifyMyMethodCalled(only());\n            verifyMyMethodCalled(after(1));\n        });\n    }\n\n    private void verifyMyMethodCalled(VerificationMode verificationMode) {\n        it(String.format(\"should call myMethod. %s\", verificationMode), () -> {\n            verify(myClass, verificationMode).myMethod();\n        });\n    }\n}\n\nExtracting the assertion and the test-naming part to a specific method (verifyMyMethodCalled(VerificationMode verificationMode)) saves a lot of boilerplate and helps with maintainability, especially since a real-life test class will most likely be longer than this example. However, the following screenshot shows why the last 3 verificationModes aren't so helpful without a proper toString() method:\n\nI fixed this, in my use case, this by extending the offending VerificationMode in a custom factory method:\nprivate static VerificationMode atMost(int times) {\n    return new AtMost(times) {\n        @Override\n        public void verify(VerificationData data) {\n            super.verify(data);\n        }\n\n        @Override\n        public String toString() {\n            return \"Wanted invocations count: at most \" + times;\n        }\n    };\n}\n\nThis quickly becomes cumbersome however, if you want to do it for multiple VerificationModes or in multiple projects. Since most user-facing VerificationModes already have a toString() method (e.g. atLeast in my example), the missing toString() methods could be included in Mockito.\nI have a PR that is almost ready for this, and would gladly submit it.\nEDIT: added Timeout to the list."
}