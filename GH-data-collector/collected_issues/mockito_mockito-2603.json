{
  "issue_id": 2602,
  "issue_url": "https://github.com/mockito/mockito/issues/2602",
  "title": "mockito-core MockitoAnnotations::openMocks initializes class twice if said class has super class",
  "description": "<h2 dir=\"auto\">Short, Self Contained, Correct (Compilable), Example:</h2>\n<p dir=\"auto\">Have a look <a href=\"https://github.com/1-alex98/mre-mockito/tree/master/src/test/java\">here </a>.<br>\nYou will find a <code class=\"notranslate\">Works</code> class and a <code class=\"notranslate\">DoesNotWork</code> class. Both are essentially the same with a small difference being the <code class=\"notranslate\">DoesNotWork</code> class does fail and extends and empty class.</p>\n<h3 dir=\"auto\">DoesNotWork.java:</h3>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"@ExtendWith({MockitoExtension.class})\npublic class DoesNotWork extends ToBeExtended{\n    @Mock\n    ToBeMocked toBeMocked;\n    @InjectMocks\n    ToBeInitialized toBeInitialized;\n\n    @Test\n    public void foo(){\n        assert toBeInitialized.toBeMocked == null;\n    }\n}\"><pre class=\"notranslate\"><code>@ExtendWith({MockitoExtension.class})\npublic class DoesNotWork extends ToBeExtended{\n    @Mock\n    ToBeMocked toBeMocked;\n    @InjectMocks\n    ToBeInitialized toBeInitialized;\n\n    @Test\n    public void foo(){\n        assert toBeInitialized.toBeMocked == null;\n    }\n}\n</code></pre></div>\n<h3 dir=\"auto\">ToBeInitialized.java:</h3>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"public class ToBeInitialized {\n    public ToBeMocked toBeMocked;\n\n    public ToBeInitialized(ToBeMocked toBeMocked) {\n        this.toBeMocked = null;\n    }\n}\"><pre class=\"notranslate\"><code>public class ToBeInitialized {\n    public ToBeMocked toBeMocked;\n\n    public ToBeInitialized(ToBeMocked toBeMocked) {\n        this.toBeMocked = null;\n    }\n}\n</code></pre></div>\n<p dir=\"auto\">Reading the docs that should work flawlessly. But it does not. As can be seen in <code class=\"notranslate\">Works.java</code> the reason is the <code class=\"notranslate\"> extends ToBeExtended</code> if you remove it everything works.</p>\n<h3 dir=\"auto\">Why does it not work</h3>\n<p dir=\"auto\">In the  <code class=\"notranslate\">DoesNotWork</code> the <code class=\"notranslate\">@InjectMocks</code> annotated instances are initialized twice. It does it twice, one time more for every super class there is. First the <code class=\"notranslate\">@InjectMocks</code> annotated instances are initialized via constructor injection. In a second round Mockito realizes that DoesNotWork.toBeInitialized is already initialized and therefore chooses Field injection over constructor injection. That makes sense if somebody does something like:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"...\n    @InjectMocks\n    Foo foo= new Foo();\n...\"><pre class=\"notranslate\"><code>...\n    @InjectMocks\n    Foo foo= new Foo();\n...\n</code></pre></div>\n<h3 dir=\"auto\">The code responsible</h3>\n<p dir=\"auto\">InjectingAnnotationEngine::processInjectMocks <div class=\"Box Box--condensed my-2\">\n  <div class=\"Box-header f6\">\n    <p class=\"mb-0 text-bold\">\n      <a href=\"https://github.com/mockito/mockito/blob/caf35b24e2764df0498469526ecb3e7ec68a0430/src/main/java/org/mockito/internal/configuration/InjectingAnnotationEngine.java#L56\">mockito/src/main/java/org/mockito/internal/configuration/InjectingAnnotationEngine.java</a>\n    </p>\n    <p class=\"mb-0 color-fg-muted\">\n         Line 56\n      in\n      <a data-pjax=\"true\" class=\"commit-tease-sha\" href=\"/mockito/mockito/commit/caf35b24e2764df0498469526ecb3e7ec68a0430\">caf35b2</a>\n    </p>\n  </div>\n  <div itemprop=\"text\" class=\"Box-body p-0 blob-wrapper blob-wrapper-embedded data\">\n    <table class=\"highlight tab-size mb-0 js-file-line-container\" data-tab-size=\"8\" data-paste-markdown-skip=\"\">\n\n        <tbody><tr class=\"border-0\">\n          <td id=\"L56\" class=\"blob-num border-0 px-3 py-0 color-bg-default\" data-line-number=\"56\"></td>\n          <td id=\"LC56\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\"> <span class=\"pl-k\">private</span> <span class=\"pl-smi\">List</span><<span class=\"pl-smi\">AutoCloseable</span>> <span class=\"pl-en\">processInjectMocks</span>( </td>\n        </tr>\n    </tbody></table>\n  </div>\n</div>\n</p>\n<p dir=\"auto\">The method is called by the MockitoExtension:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"processInjectMocks:61, InjectingAnnotationEngine (org.mockito.internal.configuration)\nprocess:48, InjectingAnnotationEngine (org.mockito.internal.configuration)\nopenMocks:82, MockitoAnnotations (org.mockito)\n<init>:43, DefaultMockitoSession (org.mockito.internal.framework)\nstartMocking:83, DefaultMockitoSessionBuilder (org.mockito.internal.session)\nbeforeEach:153, MockitoExtension (org.mockito.junit.jupiter)\"><pre class=\"notranslate\"><code>processInjectMocks:61, InjectingAnnotationEngine (org.mockito.internal.configuration)\nprocess:48, InjectingAnnotationEngine (org.mockito.internal.configuration)\nopenMocks:82, MockitoAnnotations (org.mockito)\n<init>:43, DefaultMockitoSession (org.mockito.internal.framework)\nstartMocking:83, DefaultMockitoSessionBuilder (org.mockito.internal.session)\nbeforeEach:153, MockitoExtension (org.mockito.junit.jupiter)\n</code></pre></div>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"    private List<AutoCloseable> processInjectMocks(\n            final Class<?> clazz, final Object testInstance) {\n        List<AutoCloseable> closeables = new ArrayList<>();\n        Class<?> classContext = clazz;\n        while (classContext != Object.class) {\n            closeables.add(injectCloseableMocks(testInstance));\n            classContext = classContext.getSuperclass();\n        }\n        return closeables;\n    }\"><pre class=\"notranslate\"><code>    private List<AutoCloseable> processInjectMocks(\n            final Class<?> clazz, final Object testInstance) {\n        List<AutoCloseable> closeables = new ArrayList<>();\n        Class<?> classContext = clazz;\n        while (classContext != Object.class) {\n            closeables.add(injectCloseableMocks(testInstance));\n            classContext = classContext.getSuperclass();\n        }\n        return closeables;\n    }\n</code></pre></div>\n<p dir=\"auto\">In this method for every super class the Test class has(<code class=\"notranslate\">classContext.getSuperclass()</code>) it triggers the injection(<code class=\"notranslate\"> injectCloseableMocks</code>) yet another time(<code class=\"notranslate\">while (classContext != Object.class)</code>). That might be clever if the super class has  <code class=\"notranslate\">@InjectMocks</code> annotated instances its-self. But it is odd to call <code class=\"notranslate\">closeables.add(injectCloseableMocks(testInstance));</code> instead of <code class=\"notranslate\">closeables.add(injectCloseableMocks(classContext));</code> then. For me it would make more sense to call it on the super class then instead of repeating the initialization yet another time. But I have not tested this change. I can not foresee what implications this would have. Fixing this concrete bug is probably better of in the hands of somebody that is more familiar with Mockito's internal workings.</p>\n<h2 dir=\"auto\">Why even care about this bug</h2>\n<p dir=\"auto\">Seems like it still initializes the instance right? Who does</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"public ToBeInitialized(ToBeMocked toBeMocked) {\n    this.toBeMocked = null;\n }\"><pre class=\"notranslate\"><code>public ToBeInitialized(ToBeMocked toBeMocked) {\n    this.toBeMocked = null;\n }\n</code></pre></div>\n<p dir=\"auto\">anyways?</p>\n<p dir=\"auto\">Since newer Java versions get stricter in enforcing reflections over module borders this will increasingly become an issue. In my case Mockito does access a field via reflections it is not allowed to making it fail. But it should never have tried field injection since the class had a working constructor. Dues to the bug that is descripted here it did nevertheless.</p>\n<h2 dir=\"auto\">Versions:</h2>\n<p dir=\"auto\">JDK 17, Windows 11, Mockito Version 4.4.0 (Even though this all should be reproducible elsewhere and with different versions)</p>\n<p dir=\"auto\">Thank you for working on Mockito. Great Framework <g-emoji class=\"g-emoji\" alias=\"heart\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/2764.png\">\u2764\ufe0f</g-emoji><br>\nAny more questions? I am happy to help.</p>",
  "description_text": "Short, Self Contained, Correct (Compilable), Example:\nHave a look here .\nYou will find a Works class and a DoesNotWork class. Both are essentially the same with a small difference being the DoesNotWork class does fail and extends and empty class.\nDoesNotWork.java:\n@ExtendWith({MockitoExtension.class})\npublic class DoesNotWork extends ToBeExtended{\n    @Mock\n    ToBeMocked toBeMocked;\n    @InjectMocks\n    ToBeInitialized toBeInitialized;\n\n    @Test\n    public void foo(){\n        assert toBeInitialized.toBeMocked == null;\n    }\n}\n\nToBeInitialized.java:\npublic class ToBeInitialized {\n    public ToBeMocked toBeMocked;\n\n    public ToBeInitialized(ToBeMocked toBeMocked) {\n        this.toBeMocked = null;\n    }\n}\n\nReading the docs that should work flawlessly. But it does not. As can be seen in Works.java the reason is the  extends ToBeExtended if you remove it everything works.\nWhy does it not work\nIn the  DoesNotWork the @InjectMocks annotated instances are initialized twice. It does it twice, one time more for every super class there is. First the @InjectMocks annotated instances are initialized via constructor injection. In a second round Mockito realizes that DoesNotWork.toBeInitialized is already initialized and therefore chooses Field injection over constructor injection. That makes sense if somebody does something like:\n...\n    @InjectMocks\n    Foo foo= new Foo();\n...\n\nThe code responsible\nInjectingAnnotationEngine::processInjectMocks \n\n\nmockito/src/main/java/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n\n\n         Line 56\n      in\n      caf35b2\n\n\n\n\n\n\n private List<AutoCloseable> processInjectMocks( \n\n\n\n\n\nThe method is called by the MockitoExtension:\nprocessInjectMocks:61, InjectingAnnotationEngine (org.mockito.internal.configuration)\nprocess:48, InjectingAnnotationEngine (org.mockito.internal.configuration)\nopenMocks:82, MockitoAnnotations (org.mockito)\n:43, DefaultMockitoSession (org.mockito.internal.framework)\nstartMocking:83, DefaultMockitoSessionBuilder (org.mockito.internal.session)\nbeforeEach:153, MockitoExtension (org.mockito.junit.jupiter)\n\n    private List processInjectMocks(\n            final Class clazz, final Object testInstance) {\n        List closeables = new ArrayList<>();\n        Class classContext = clazz;\n        while (classContext != Object.class) {\n            closeables.add(injectCloseableMocks(testInstance));\n            classContext = classContext.getSuperclass();\n        }\n        return closeables;\n    }\n\nIn this method for every super class the Test class has(classContext.getSuperclass()) it triggers the injection( injectCloseableMocks) yet another time(while (classContext != Object.class)). That might be clever if the super class has  @InjectMocks annotated instances its-self. But it is odd to call closeables.add(injectCloseableMocks(testInstance)); instead of closeables.add(injectCloseableMocks(classContext)); then. For me it would make more sense to call it on the super class then instead of repeating the initialization yet another time. But I have not tested this change. I can not foresee what implications this would have. Fixing this concrete bug is probably better of in the hands of somebody that is more familiar with Mockito's internal workings.\nWhy even care about this bug\nSeems like it still initializes the instance right? Who does\npublic ToBeInitialized(ToBeMocked toBeMocked) {\n    this.toBeMocked = null;\n }\n\nanyways?\nSince newer Java versions get stricter in enforcing reflections over module borders this will increasingly become an issue. In my case Mockito does access a field via reflections it is not allowed to making it fail. But it should never have tried field injection since the class had a working constructor. Dues to the bug that is descripted here it did nevertheless.\nVersions:\nJDK 17, Windows 11, Mockito Version 4.4.0 (Even though this all should be reproducible elsewhere and with different versions)\nThank you for working on Mockito. Great Framework \u2764\ufe0f\nAny more questions? I am happy to help."
}