{
  "issue_id": 2363,
  "issue_url": "https://github.com/assertj/assertj/issues/2363",
  "title": "Extracting through field names not supported for optional in java 17",
  "description": "<h4 dir=\"auto\">Summary</h4>\n<p dir=\"auto\">I'm upgrading to java 17 (from java 11), and I have some tests failing due to an incompatibility between java 17 and assertJ.<br>\nOne of the breaking changes introduced by java 17 is <a href=\"https://openjdk.java.net/jeps/396\" rel=\"nofollow\">JEP 396: Strongly Encapsulate JDK Internals by Default</a>.<br>\nIt seems that assertJ try to force access to non public value (not public) when extracting them through field name => extract the value from an optional (\"object.value\") and since the value is not public I got this exception:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"org.assertj.core.util.introspection.IntrospectionError: \nCan't find any field or property with name 'value'.\nError when introspecting properties was :\n- No getter for property 'value' in java.util.Optional \nError when introspecting fields was :\n- Unable to obtain the value of the field <'value'> from <Optional[john]>\n\n\tat org.assertj.core.util.introspection.PropertyOrFieldSupport.getSimpleValue(PropertyOrFieldSupport.java:88)\n\tat org.assertj.core.util.introspection.PropertyOrFieldSupport.getValueOf(PropertyOrFieldSupport.java:60)\n\tat org.assertj.core.util.introspection.PropertyOrFieldSupport.getValueOf(PropertyOrFieldSupport.java:57)\n\tat org.assertj.core.extractor.ByNameSingleExtractor.apply(ByNameSingleExtractor.java:29)\n\tat org.assertj.core.api.AbstractAssert.extracting(AbstractAssert.java:1059)\n\tat org.assertj.core.api.AbstractObjectAssert.extracting(AbstractObjectAssert.java:834)\n\tat fr.witchbird.cl.negotiation.test.functional.VersionIT.should_access(VersionIT.java:165)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n\tat org.junit.runner.JUnitCore.run(JUnitCore.java:137)\n\tat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)\n\tat com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33)\n\tat com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:235)\n\tat com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:54)\nCaused by: org.assertj.core.util.introspection.IntrospectionError: Unable to obtain the value of the field <'value'> from <Optional[john]>\n\tat org.assertj.core.util.introspection.FieldSupport.readSimpleField(FieldSupport.java:248)\n\tat org.assertj.core.util.introspection.FieldSupport.fieldValue(FieldSupport.java:202)\n\tat org.assertj.core.util.introspection.PropertyOrFieldSupport.getSimpleValue(PropertyOrFieldSupport.java:70)\n\t... 28 more\nCaused by: java.lang.reflect.InaccessibleObjectException: Unable to make field private final java.lang.Object java.util.Optional.value accessible: module java.base does not \"opens java.util\" to unnamed module @7fbe847c\n\tat java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:354)\n\tat java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:297)\n\tat java.base/java.lang.reflect.Field.checkCanSetAccessible(Field.java:178)\n\tat java.base/java.lang.reflect.Field.setAccessible(Field.java:172)\n\tat org.assertj.core.util.introspection.FieldUtils.getField(FieldUtils.java:67)\n\tat org.assertj.core.util.introspection.FieldUtils.readField(FieldUtils.java:143)\n\tat org.assertj.core.util.introspection.FieldSupport.readSimpleField(FieldSupport.java:208)\n\t... 30 more\"><pre class=\"notranslate\"><code>org.assertj.core.util.introspection.IntrospectionError: \nCan't find any field or property with name 'value'.\nError when introspecting properties was :\n- No getter for property 'value' in java.util.Optional \nError when introspecting fields was :\n- Unable to obtain the value of the field <'value'> from <Optional[john]>\n\n\tat org.assertj.core.util.introspection.PropertyOrFieldSupport.getSimpleValue(PropertyOrFieldSupport.java:88)\n\tat org.assertj.core.util.introspection.PropertyOrFieldSupport.getValueOf(PropertyOrFieldSupport.java:60)\n\tat org.assertj.core.util.introspection.PropertyOrFieldSupport.getValueOf(PropertyOrFieldSupport.java:57)\n\tat org.assertj.core.extractor.ByNameSingleExtractor.apply(ByNameSingleExtractor.java:29)\n\tat org.assertj.core.api.AbstractAssert.extracting(AbstractAssert.java:1059)\n\tat org.assertj.core.api.AbstractObjectAssert.extracting(AbstractObjectAssert.java:834)\n\tat fr.witchbird.cl.negotiation.test.functional.VersionIT.should_access(VersionIT.java:165)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n\tat org.junit.runner.JUnitCore.run(JUnitCore.java:137)\n\tat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)\n\tat com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33)\n\tat com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:235)\n\tat com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:54)\nCaused by: org.assertj.core.util.introspection.IntrospectionError: Unable to obtain the value of the field <'value'> from <Optional[john]>\n\tat org.assertj.core.util.introspection.FieldSupport.readSimpleField(FieldSupport.java:248)\n\tat org.assertj.core.util.introspection.FieldSupport.fieldValue(FieldSupport.java:202)\n\tat org.assertj.core.util.introspection.PropertyOrFieldSupport.getSimpleValue(PropertyOrFieldSupport.java:70)\n\t... 28 more\nCaused by: java.lang.reflect.InaccessibleObjectException: Unable to make field private final java.lang.Object java.util.Optional.value accessible: module java.base does not \"opens java.util\" to unnamed module @7fbe847c\n\tat java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:354)\n\tat java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:297)\n\tat java.base/java.lang.reflect.Field.checkCanSetAccessible(Field.java:178)\n\tat java.base/java.lang.reflect.Field.setAccessible(Field.java:172)\n\tat org.assertj.core.util.introspection.FieldUtils.getField(FieldUtils.java:67)\n\tat org.assertj.core.util.introspection.FieldUtils.readField(FieldUtils.java:143)\n\tat org.assertj.core.util.introspection.FieldSupport.readSimpleField(FieldSupport.java:208)\n\t... 30 more\n</code></pre></div>\n<h4 dir=\"auto\">Example</h4>\n<div class=\"highlight highlight-source-java notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"       private static class Person {\n\t\tprivate final Optional<String> name;\n\n\t\tpublic Person(final Optional<String> name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic Optional<String> getName() {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\t@Test\n\tpublic void should_access() {\n\t\tfinal Optional<String> name = Optional.of(\"john\");\n\t\tfinal var person = new Person(name);\n\t\tAssertions.assertThat(person)\n\t\t        .extracting(\"name.value\")\n\t\t        .isEqualTo(\"john\");\n\t}\"><pre>       <span class=\"pl-k\">private</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">class</span> <span class=\"pl-smi\">Person</span> {\n\t\t<span class=\"pl-k\">private</span> <span class=\"pl-k\">final</span> <span class=\"pl-smi\">Optional</span><<span class=\"pl-smi\">String</span>> <span class=\"pl-s1\">name</span>;\n\n\t\t<span class=\"pl-k\">public</span> <span class=\"pl-smi\">Person</span>(<span class=\"pl-k\">final</span> <span class=\"pl-smi\">Optional</span><<span class=\"pl-smi\">String</span>> <span class=\"pl-s1\">name</span>) {\n\t\t\t<span class=\"pl-smi\">this</span>.<span class=\"pl-s1\">name</span> = <span class=\"pl-s1\">name</span>;\n\t\t}\n\n\t\t<span class=\"pl-k\">public</span> <span class=\"pl-smi\">Optional</span><<span class=\"pl-smi\">String</span>> <span class=\"pl-en\">getName</span>() {\n\t\t\t<span class=\"pl-k\">return</span> <span class=\"pl-s1\">name</span>;\n\t\t}\n\t}\n\n\t<span class=\"pl-c1\">@</span><span class=\"pl-c1\">Test</span>\n\t<span class=\"pl-k\">public</span> <span class=\"pl-smi\">void</span> <span class=\"pl-s1\">should_access</span>() {\n\t\t<span class=\"pl-k\">final</span> <span class=\"pl-smi\">Optional</span><<span class=\"pl-smi\">String</span>> <span class=\"pl-s1\">name</span> = <span class=\"pl-s1\">Optional</span>.<span class=\"pl-en\">of</span>(<span class=\"pl-s\">\"john\"</span>);\n\t\t<span class=\"pl-k\">final</span> <span class=\"pl-smi\">var</span> <span class=\"pl-s1\">person</span> = <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Person</span>(<span class=\"pl-s1\">name</span>);\n\t\t<span class=\"pl-s1\">Assertions</span>.<span class=\"pl-en\">assertThat</span>(<span class=\"pl-s1\">person</span>)\n\t\t        .<span class=\"pl-en\">extracting</span>(<span class=\"pl-s\">\"name.value\"</span>)\n\t\t        .<span class=\"pl-en\">isEqualTo</span>(<span class=\"pl-s\">\"john\"</span>);\n\t}</pre></div>",
  "description_text": "Summary\nI'm upgrading to java 17 (from java 11), and I have some tests failing due to an incompatibility between java 17 and assertJ.\nOne of the breaking changes introduced by java 17 is JEP 396: Strongly Encapsulate JDK Internals by Default.\nIt seems that assertJ try to force access to non public value (not public) when extracting them through field name => extract the value from an optional (\"object.value\") and since the value is not public I got this exception:\norg.assertj.core.util.introspection.IntrospectionError: \nCan't find any field or property with name 'value'.\nError when introspecting properties was :\n- No getter for property 'value' in java.util.Optional \nError when introspecting fields was :\n- Unable to obtain the value of the field <'value'> from \n\n\tat org.assertj.core.util.introspection.PropertyOrFieldSupport.getSimpleValue(PropertyOrFieldSupport.java:88)\n\tat org.assertj.core.util.introspection.PropertyOrFieldSupport.getValueOf(PropertyOrFieldSupport.java:60)\n\tat org.assertj.core.util.introspection.PropertyOrFieldSupport.getValueOf(PropertyOrFieldSupport.java:57)\n\tat org.assertj.core.extractor.ByNameSingleExtractor.apply(ByNameSingleExtractor.java:29)\n\tat org.assertj.core.api.AbstractAssert.extracting(AbstractAssert.java:1059)\n\tat org.assertj.core.api.AbstractObjectAssert.extracting(AbstractObjectAssert.java:834)\n\tat fr.witchbird.cl.negotiation.test.functional.VersionIT.should_access(VersionIT.java:165)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n\tat org.junit.runner.JUnitCore.run(JUnitCore.java:137)\n\tat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)\n\tat com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33)\n\tat com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:235)\n\tat com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:54)\nCaused by: org.assertj.core.util.introspection.IntrospectionError: Unable to obtain the value of the field <'value'> from \n\tat org.assertj.core.util.introspection.FieldSupport.readSimpleField(FieldSupport.java:248)\n\tat org.assertj.core.util.introspection.FieldSupport.fieldValue(FieldSupport.java:202)\n\tat org.assertj.core.util.introspection.PropertyOrFieldSupport.getSimpleValue(PropertyOrFieldSupport.java:70)\n\t... 28 more\nCaused by: java.lang.reflect.InaccessibleObjectException: Unable to make field private final java.lang.Object java.util.Optional.value accessible: module java.base does not \"opens java.util\" to unnamed module @7fbe847c\n\tat java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:354)\n\tat java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:297)\n\tat java.base/java.lang.reflect.Field.checkCanSetAccessible(Field.java:178)\n\tat java.base/java.lang.reflect.Field.setAccessible(Field.java:172)\n\tat org.assertj.core.util.introspection.FieldUtils.getField(FieldUtils.java:67)\n\tat org.assertj.core.util.introspection.FieldUtils.readField(FieldUtils.java:143)\n\tat org.assertj.core.util.introspection.FieldSupport.readSimpleField(FieldSupport.java:208)\n\t... 30 more\n\nExample\n       private static class Person {\n\t\tprivate final Optional<String> name;\n\n\t\tpublic Person(final Optional<String> name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic Optional<String> getName() {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\t@Test\n\tpublic void should_access() {\n\t\tfinal Optional<String> name = Optional.of(\"john\");\n\t\tfinal var person = new Person(name);\n\t\tAssertions.assertThat(person)\n\t\t        .extracting(\"name.value\")\n\t\t        .isEqualTo(\"john\");\n\t}"
}