{
  "issue_id": 3187,
  "issue_url": "https://github.com/FasterXML/jackson-databind/issues/3187",
  "title": "`AnnotatedMember.equals()` does not work reliably",
  "description": "<p dir=\"auto\">Hi,</p>\n<p dir=\"auto\">I noticed some strange behavior of the current <code class=\"notranslate\">AnnotatedMember.equals()</code> implementations. Following test case for <code class=\"notranslate\">AnnotatedConstructor.equals()</code> currently fails:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"public void testAnnotatedConstructorEquality() {\n    ObjectMapper mapper = new ObjectMapper();\n    DeserializationConfig context = mapper.getDeserializationConfig();\n    JavaType beanType = mapper.constructType(SomeBean.class);\n\n    AnnotatedClass instance1 = AnnotatedClassResolver.resolve(context, beanType, context);\n    AnnotatedClass instance2 = AnnotatedClassResolver.resolve(context, beanType, context);\n\n    // Successful\n    assertEquals(instance1, instance2);\n    assertEquals(instance1.getDefaultConstructor().getAnnotated(), instance2.getDefaultConstructor().getAnnotated());\n    \n    // Fails\n    assertEquals(instance1.getDefaultConstructor(), instance2.getDefaultConstructor());\n}\"><pre class=\"notranslate\"><code>public void testAnnotatedConstructorEquality() {\n    ObjectMapper mapper = new ObjectMapper();\n    DeserializationConfig context = mapper.getDeserializationConfig();\n    JavaType beanType = mapper.constructType(SomeBean.class);\n\n    AnnotatedClass instance1 = AnnotatedClassResolver.resolve(context, beanType, context);\n    AnnotatedClass instance2 = AnnotatedClassResolver.resolve(context, beanType, context);\n\n    // Successful\n    assertEquals(instance1, instance2);\n    assertEquals(instance1.getDefaultConstructor().getAnnotated(), instance2.getDefaultConstructor().getAnnotated());\n    \n    // Fails\n    assertEquals(instance1.getDefaultConstructor(), instance2.getDefaultConstructor());\n}\n</code></pre></div>\n<p dir=\"auto\">Based on the first two successful <code class=\"notranslate\">assertEquals(...)</code> statements, I would have expected that the third <code class=\"notranslate\">assertEquals(...)</code> should be also successful. However, it currently fails.</p>\n<p dir=\"auto\">The reason for this behavior is that <code class=\"notranslate\">AnnotatedConstructor.equals()</code> is currently using <code class=\"notranslate\">==</code> for comparing the two constructors:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"public boolean equals(Object o) {\n    if (o == this) return true;\n    return ClassUtil.hasClass(o, getClass())\n            && (((AnnotatedConstructor) o)._constructor == _constructor);\n}\"><pre class=\"notranslate\"><code>public boolean equals(Object o) {\n    if (o == this) return true;\n    return ClassUtil.hasClass(o, getClass())\n            && (((AnnotatedConstructor) o)._constructor == _constructor);\n}\n</code></pre></div>\n<p dir=\"auto\">However, the implementation of the reflection API in <code class=\"notranslate\">java.lang.Class</code> is always copying / cloning the <code class=\"notranslate\">Field</code>, <code class=\"notranslate\">Method</code> and <code class=\"notranslate\">Constructor</code> instances prior to returning them to the caller (e.g. see <code class=\"notranslate\">Class.copyConstructors()</code>). Thus, each call of <code class=\"notranslate\">Class.getConstructors()</code> will always return new instances.</p>\n<p dir=\"auto\">If you agree that the above test case should be successful (i.e. also <code class=\"notranslate\">assertEquals(instance1.getDefaultConstructor(), instance2.getDefaultConstructor())</code> should be successful), I would prepare a corresponding pull request that slightly modifies the current implementation of the <code class=\"notranslate\">equals()</code> method for all subclasses of <code class=\"notranslate\">AnnotatedMember</code> that are affected by this problem (i.e. at least <code class=\"notranslate\">AnnotatedField</code>, <code class=\"notranslate\">AnnotatedConstructor</code> and <code class=\"notranslate\">AnnotatedMethod</code>).</p>",
  "description_text": "Hi,\nI noticed some strange behavior of the current AnnotatedMember.equals() implementations. Following test case for AnnotatedConstructor.equals() currently fails:\npublic void testAnnotatedConstructorEquality() {\n    ObjectMapper mapper = new ObjectMapper();\n    DeserializationConfig context = mapper.getDeserializationConfig();\n    JavaType beanType = mapper.constructType(SomeBean.class);\n\n    AnnotatedClass instance1 = AnnotatedClassResolver.resolve(context, beanType, context);\n    AnnotatedClass instance2 = AnnotatedClassResolver.resolve(context, beanType, context);\n\n    // Successful\n    assertEquals(instance1, instance2);\n    assertEquals(instance1.getDefaultConstructor().getAnnotated(), instance2.getDefaultConstructor().getAnnotated());\n    \n    // Fails\n    assertEquals(instance1.getDefaultConstructor(), instance2.getDefaultConstructor());\n}\n\nBased on the first two successful assertEquals(...) statements, I would have expected that the third assertEquals(...) should be also successful. However, it currently fails.\nThe reason for this behavior is that AnnotatedConstructor.equals() is currently using == for comparing the two constructors:\npublic boolean equals(Object o) {\n    if (o == this) return true;\n    return ClassUtil.hasClass(o, getClass())\n            && (((AnnotatedConstructor) o)._constructor == _constructor);\n}\n\nHowever, the implementation of the reflection API in java.lang.Class is always copying / cloning the Field, Method and Constructor instances prior to returning them to the caller (e.g. see Class.copyConstructors()). Thus, each call of Class.getConstructors() will always return new instances.\nIf you agree that the above test case should be successful (i.e. also assertEquals(instance1.getDefaultConstructor(), instance2.getDefaultConstructor()) should be successful), I would prepare a corresponding pull request that slightly modifies the current implementation of the equals() method for all subclasses of AnnotatedMember that are affected by this problem (i.e. at least AnnotatedField, AnnotatedConstructor and AnnotatedMethod)."
}